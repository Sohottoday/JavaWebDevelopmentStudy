



### 진수

- 비트(bit) : 컴퓨터에서 자료를 표현하는 최소 단위 0 또는 1

- 바이트(byte) : 8bit

- 이진수 : 컴퓨터에서 표현되는 자료의 형태

  ​				0000 1010 (이진수) => 10 (십진수)

- 8진수 : 이진수를 3비트씩 모아서 표현

  - 한자리에 1~8까지 표현

- 16진수 : 이진수를 4비트씩 모아서 표현

  - 한자리에 1~15까지 표현, 0~9 and A, B, C, D, E, F
  - 16을 표현할 때 10(16진수)



- 보수

  보충해주는 수

  - ex) 10의 보수 : 10이 되기 위한 수

    6 = 4, 5 = 5

- 컴퓨터에서 음수 표현하기

  - 2의 보수로 표현

  - 양수와 음수는 더해서 0이 되어야 함

    0000 0101 (5)

    1111 1010 (1의 보수)

    1111 1011 (5에 대한 2의 보수)			// 두 수를 더하면 0이 됨

  - 2의 보수 만드는 방법(음수 만드는 방법) : 1의 보수를 취하고 나서 1을 더해 준다.

### 변수와 자료형

#### 변수

- 변하는 수
- 사람의 나이, 온라인 상품의 개수, 학생의 학년
- 변하는 값을 프로그램에서 나타내기 위한 방법



- 변수 선언하기

  자료형 변수이름;

  int age;



- 변수와 메모리

  변수를 선언하는 것은 해당 자료형의 크기 만큼의 메모리를 사용하겠다는 것

  메모리 위치를 변수 이름으로 참조

  `int age;` => 4 바이트 메모리

- 변수 이름 규칙

  - 영문자나 숫자를 사용함. 단 숫자로 시작할 수 없음

  - 특수문자 중에는 '_'와 '$'만 사용 가능

  - 예약어(reserved word)는 사용할 수 없음

  - 변수는 그 쓰임에 맞는 이름으로 명명하는 것이 가독성에 좋음

  - 약어로 사용하는 것은 좋지 않은 습관

#### 자료형

- 기본형 : 자바 언어에서 기본적으로 제공해 주는 자료형

  메모리의 크기가 정해져 있음

  정수형, 문자형, 실수형, 논리형

- 참조형 : 클래스 자료형

  JDK에서 제공되는 클래스와 프로그래머가 정의하는 클래스

  클래스에 따라 사용하는 크기가 다름

  ex) String, Student ...

- 기본 자료형

|       | 정수형 | 문자형 | 실수형 | 논리형  |
| ----- | ------ | ------ | ------ | ------- |
| 1byte | byte   |        |        | boolean |
| 2byte | short  | char   |        |         |
| 4byte | int    |        | float  |         |
| 8byte | long   |        | double |         |

##### 문자 자료형

- 내부적으로는 비트의 조합으로 표현
- 인코딩 - 각 문자에 따른 특정한 숫자 값(코드 값)을 부여
- 디코딩 - 숫자 값을 원래의 문자로 변환
- 문자 세트 : 문자를 위한 코드 값(숫자 값) 들을 정해 놓은 세트
  - 아스키(ASCII) : 1바이트로 영문자, 숫자, 특수문자 등을 표현 함
  - 유니코드(Unicode) : 한글과 같은 복잡한 언어를 표현하기 위한 표준 인코딩 UTF-8, UTF-16이 대표적
  - 문자를 변수에 저장하면? 문자에 해당하는 코드 값이 저장됨

##### 실수

- 실수는 double 자료형이 기본

- float를 사용할 때 f, F 식별자를 사용

- 부동 소수점 방식

  실수를 지수부와 가수부로 표현함

- 부동 소수점 방식의 오류

  - 지수와 가수로 표현 되는 부동 소수점은 0을 표현할 수 없음

    따라서 부동 소수점 방식에서는 약간의 오차가 발생할 수 있다.

##### 논리 자료형

- boolean으로 표현
- True(참), False(거짓) 값 존재



#### 자료형 없이 변수 사용하기(Java 10)

- 지역 변수 자료형 추론(local variable type inference)

  변수에 대입되는 값을 보고 컴파일러가 추론

  `var num = 10;`	: int형으로 인식

  `var str = "hello";` : String형으로 인식



#### 상수와 리터럴

- 상수(constant) : 변하지 않는 수

- 리터럴(literal) : 프로그램에서 사용하는 모든 숫자, 값, 논리 값

  ex) 10, 3.14, 'A', true

- 모든 리터럴은 상수 풀(constant pool)에 저장되어 있음

- 상수 풀에 저장될 때 정수는 int, 실수는 double로 저장 됨

#### 형 변환

- 서로 다른 자료형의 값이 대입되는 경우 형 변환이 일어 남
- 묵시적 형 변환(implicit type conversion) 
  - 작은 수에서 큰 수로
  - 덜 정밀한 수에서 더 정밀한 수로 대입되는 경우
- 명시적 형 변환(explicit type conversion)
  - 변환 되는 자료 형을 명시
  - 자료의 손실이 발생할 수 있음

##### 진수형

- 10을 각 진법으로 쓰면
  - 2진수 `0B1010;`
  - 8진수 `012;`
  - 16진수 `0XA;`



### 연산자

#### 항과 연산자

- 항(operand) : 연산에 사용되는 값
- 연산자(operator) : 항을 이용하여 연산하는 기호

- 항의 개수와 연산자
  - 단항 연산자 : 항이 한 개인 연산자 => `++num;`
  - 이항 연산자 : 항이 두 개인 연산자 => `num1 + num2;`
  - 삼항 연산자 : 항이 세 개인 연산자 => `(5>3) ? 1 : 0;`

- 대입 연산자

  `int age = 20;`

  왼쪽 변수의 값이 오른쪽에 대입

  우선순위가 가장 낮은 연산자

- 부호 연산자

  - 단항 연산자

    변수의 부호를 유지하거나(+) 바꿈(-)

    실제 변수의 값이 변하려면 대입연산자를 사용해야 함

- 산술 연산자

  - \+ : 두 항을 더한다.
  - \- : 앞 항에서 뒤 항을 뺀다.
  - \* : 두 항을 곱한다.
  - / : 앞 항에서 뒤 항을 나눈다.
  - % :  앞 항에서 뒤 항을 나눈 나머지 값

  - %는 나머지를 구하는 연산자

    숫자 n의 나머지 범위는 0~n-1

- 복합 대입 연산자
  
  - 대입 연산자와 다른 연산자가 함께 쓰임

| 연산자 | 기능                                                         | 연산 예                                          |
| ------ | ------------------------------------------------------------ | ------------------------------------------------ |
| +=     | 두 항의 값을 더해서 왼쪽 항에 대입                           | num += 2;<br />num1 = num1 + 2;와 같음           |
| -=     | 왼쪽 항에서 오른쪽 항을 빼서 그 값을 왼쪽 항에 대입          | num1 -= 2;<br />num1 = num1 - 2; 와 같음         |
| *=     | 두 항의 값을 곱해서 왼쪽 항에 대입                           | num1 * 2;<br />num1 = num1 * 2; 와 같음          |
| /=     | 왼쪽 항을 오른쪽 항으로 나누어 그 몫을 왼쪽 항에 대입        | num1 /= 2;<br />num1 = num1 / 2; 와 같음         |
| %=     | 왼쪽 항을 오른쪽 항으로 나누어 그  나머지를 왼쪽 항에 대입   | num1 %= 2;<br />num1 = num1 % 2; 와 같음         |
| <<=    | 비트를 왼쪽으로 이동하고 그 값을 왼쪽 항에 대입              | num1 <<= 2;<br />num1 = num1 << 2; 와 같음       |
| >>=    | 비트를 오른쪽으로 이동하고 그 값을 왼쪽 항에 대입<br />(왼쪽에 채워지는 비트 값은 부호 비트와 동일) | num1 >>= 2;<br />num1 = num1 >> 2; 와 같음       |
| >>>=   | 비트를 오른쪽으로 이동하고 그 값을 왼쪽 항에 대입<br />(왼쪽에 채워지는 비트 값은 0) | num1 >>>= 2;<br />num1 = num1 >>> 2; 와 같음     |
| &=     | 두 항의 & 비트 연산 후 그 값을 왼쪽 항에 대입                | num1 &= num2;<br />num1 = num1 & num2; 와 같음   |
| \|=    | 두 항의 \| 비트 연산 후 그 값을 왼쪽 항에 대입               | num1 \|= num2;<br />num1 = num1 \| num2; 와 같음 |
| ^=     | 두 항의 ^ 비트 연산 후 그 값을 왼쪽 항에 대입                | num1 ^= num2;<br />num1 = num1 ^ num2; 와 같음   |



- 증가, 감수 연산자
  - 단항 연산자
  - 변수의 값을  1 더하거나 뺄 때 사용
  - 연산자가 항의 앞에 있는가 뒤에 있는가에 따라 그 결과가 달라짐

| 연산자 | 기능               | 연산 예                                                      |
| ------ | ------------------ | ------------------------------------------------------------ |
| ++     | 항의 값에 1을 더함 | val = ++num; *// 먼저 num값이 1 증가한 후 val 변수에 대입*<br />val = num++; *// val 변수에 기존 num 값을 먼저 대입한 후 num값 1 증가* |
| --     | 항의 값에 1을 뺌   | val = --num; *// 먼저 num값이 1 감소한 후 val 변수에 대입*<br />val = num--; *// val 변수에 기존 num 값을 먼저 대입한 후 num값 1 감소* |



- 관계 연산자
  - 연산의 결과가 true/false 로 반환됨
  - 비교 연산자 라고도 함
  - \>, <, >=, <=, ==, !=

- 논리 연산자
  - 관계 연산자와 함께 많이 사용됨
  - 연산의 결과가 true/false로 반환 됨

| 연산자              | 기능                                                         | 연산 예                                  |
| ------------------- | ------------------------------------------------------------ | ---------------------------------------- |
| &&<br />(논리 곱)   | 두 항이 모두 참인 경우에만 결과 값이 참. 그렇지 않은 경우는 거짓 | booleanval =<br />(5 > 3) && (5 > 2);    |
| \|\|<br />(논리 합) | 두 항 중 하나의 항만 참이면 결과 값은 참. 두 항이 모두 거짓이면 결과 값은 거짓 | booleanval = <br />(5 > 3) \|\| (5 < 2); |
| !<br />(부정)       | 단항 연산자. 참인 경우 거짓으로 바꾸고, 거짓인 경우 참으로 변환 | booleanval = !(5 > 3);                   |

- 단락 회로 평가(short circuit evaluation)

  - 논리 곱(&&)은 두 항이 모두 true일 때만 결과가 true

    앞의 항이 false 이면 뒤 항의 결과를 평가하지 않아도 false

  - 논리 합(||)은 두 항이 모두 false 일 때만 결과가 false

    앞의 항이 true 이면 뒤 항의 결과를 평가하지 않아도 true

  - 실제 프로그램에서 예상하지 않는 결과가 발생할 수 있으므로 유의

- 조건 연산자

  - 삼항 연산자

    조건식? 결과 1 : 결과 2;

    조건이 true면 결과 1을 반환하고 false면 결과 2를 반환한다.

    `int num = (5>3)? 10: 20;`

    간단한 조건문 대신 사용할 수 있는 연산자



- 비트 연산자

| 연산자 | 설명                  | 예                                                      |
| ------ | --------------------- | ------------------------------------------------------- |
| ~      | 비트의 반전(1의 보수) | a = ~a;                                                 |
| &      | 비트 단위 AND         | 1 & 1    1 반환 그 외는 0                               |
| \|     | 비트 단위 OR          | 0 \| 0    0 반환 그 외는 1                              |
| ^      | 비트 단위 XOR         | 두개의 비트가 서로 다른 경우에 1을 반환                 |
| <<     | 왼쪽 shift            | a << 2    변수 a를 2비트 만큼 왼쪽으로 이동             |
| \>>    | 오른쪽 shift          | a >> 2    변수 a를 2비트 만큼 오른쪽으로 이동           |
| \>>>   | 오른쪽 shift          | \>> 동일한 연산    채워지는 비트가 부호와 상관 없이 0임 |

​	대입 연산자와 다른 연산자가 함께 쓰임

​	마스크 : 특정 비트를 가리고 몇 개의 비트값만 사용할 때

​	비트켜기 : 특정 비트들만을 1로 설정해서 사용하고 싶을 때

​		ex) &00001111 (하위 4비트 중 1인 비트만 꺼내기)

​	비트끄기 : 특정 비트들만을 0으로 설정해서 사용하고 싶을 때

​		ex) |11110000 (하위 4비트 중 0인 비트만 0으로 만들기)

​	비트 토글 : 모든 비트들을 0은 1로, 1은 0으로 바꾸고 싶을 때



### 제어문

#### 조건문

##### if 문, if-else문

- 조건식의 결과에 따라 수행문이 실행되는 조건문

``` java
if(조건식) {
    수행문;
}

if(조건식) {
    수행문 1;
} else {
    수행문 2;
}
```

- 간단한 if-else문은 조건 연산자(삼항 연산자)로 구현할 수 있다.



##### switch-case문

- 조건이 정수, 문자열 값으로 그 값에 따라 수행 결과가 달라지는 경우 if-else와 같은 의미로 수행

``` java
switch(rank) {
    case 1 : medalColor = 'G';
        break;
    case 2 : medalColor = 'S';
        break;
    case 3 : medalColor = 'B';
        break;
    default : medalColor = 'C';
}
```



#### 반복문

- 동일한 수행문을 조건에 맞는 동안 수행하도록 하는 기능

  ex) 달리는 자동차, 일정 횟수만큼 돌아가는 나사, 특정 온도까지 가동되는 에어컨

##### while문

- 조건이 참인 동안 수행문이 반복해서 수행됨

``` java
while(조건식) {
    수행문 1;
    ...
}
	수행문 2;
	...
```

##### do-while문

- 먼저 수행문을 수행하고 조건 체크
- 한번 이상 수행문이 수행되어야 하는 경우 사용
- 조건식을 뒤에서 확인한다고 생각하면 된다.

``` java
do {
    수행문 1;
    ...
} while(조건식);
	수행문2;
	...
```



##### for문

- 일정 횟수에 기반한 반복을 구현할 때 효율적
- 반복문 중 가장 많이 사용됨

``` java
for(초기화식; 조건식; 증감식){
    수행문;
    .....
}
```

#### 중첩 반복문

- 반복문이 중첩되어 구현되는 경우
- 반복문 내부에 또 다른 반복문이 있음
- 외부 반복문과 내부 반복문 간의 변수 값 변화에 유의하며 구현해야 함



#### 제어문 내 제어문

##### break문

- 감싸고 있는 블록의 제어를 빠져나오는 기능
- 반복문, 조건문, switch-case 등과 같이 쓰이며 현재 수행하고 있던 블록에서 수행을 중지하고 외부로 제어가 이동함
- 반복문과 같이 사용하면 특정 조건일 때 반복을 중지하는 기능을 구현할 수 있음

##### continue문

- 반복의 수행 중 조건문과 조건이 맞는 경우 이후 블록 내부의 다른 수행문을 수행하지 않음





